import { deepCopy, isFunction, isArray, isObject, isString } from "@intlify/shared";
export async function loadVueI18nOptions(vueI18nConfigs, nuxt) {
  const vueI18nOptions = { messages: {} };
  for (const configFile of vueI18nConfigs) {
    const { default: resolver } = await configFile();
    const resolved = typeof resolver === "function" ? await nuxt.runWithContext(async () => await resolver()) : resolver;
    deepCopy(resolved, vueI18nOptions);
  }
  return vueI18nOptions;
}
export function makeFallbackLocaleCodes(fallback, locales) {
  let fallbackLocales = [];
  if (isArray(fallback)) {
    fallbackLocales = fallback;
  } else if (isObject(fallback)) {
    const targets = [...locales, "default"];
    for (const locale of targets) {
      if (fallback[locale]) {
        fallbackLocales = [...fallbackLocales, ...fallback[locale].filter(Boolean)];
      }
    }
  } else if (isString(fallback) && locales.every((locale) => locale !== fallback)) {
    fallbackLocales.push(fallback);
  }
  return fallbackLocales;
}
export async function loadInitialMessages(messages, localeLoaderMessages, options) {
  const { defaultLocale, initialLocale, localeCodes, fallbackLocale, lazy, cacheMessages } = options;
  const setter = (locale, message) => {
    const base = messages[locale] || {};
    deepCopy(message, base);
    messages[locale] = base;
  };
  if (lazy && fallbackLocale) {
    const fallbackLocales = makeFallbackLocaleCodes(fallbackLocale, [defaultLocale, initialLocale]);
    await Promise.all(
      fallbackLocales.map((locale) => loadLocale({ locale, setter, localeMessages: localeLoaderMessages }, cacheMessages))
    );
  }
  const locales = lazy ? [...(/* @__PURE__ */ new Set()).add(defaultLocale).add(initialLocale)] : localeCodes;
  await Promise.all(
    locales.map((locale) => loadLocale({ locale, setter, localeMessages: localeLoaderMessages }, cacheMessages))
  );
  return messages;
}
async function loadMessage(locale, { key, load }, cacheMessages) {
  let message = null;
  try {
    __DEBUG__ && console.log("loadMessage: (locale) -", locale);
    const getter = await load().then((r) => r.default || r);
    if (isFunction(getter)) {
      message = await getter(locale);
      __DEBUG__ && console.log("loadMessage: dynamic load", message);
    } else {
      message = getter;
      if (message != null && cacheMessages) {
        cacheMessages.set(key, message);
      }
      __DEBUG__ && console.log("loadMessage: load", message);
    }
  } catch (e) {
    console.error("Failed locale loading: " + e.message);
  }
  return message;
}
export async function loadLocale({
  locale,
  localeMessages,
  setter
}, cacheMessages) {
  const loaders = localeMessages[locale];
  if (loaders == null) {
    console.warn("Could not find messages for locale code: " + locale);
    return;
  }
  const targetMessage = {};
  for (const loader of loaders) {
    let message = null;
    if (cacheMessages && cacheMessages.has(loader.key) && loader.cache) {
      __DEBUG__ && console.log(loader.key + " is already loaded");
      message = cacheMessages.get(loader.key);
    } else {
      __DEBUG__ && !loader.cache && console.log(loader.key + " bypassing cache!");
      __DEBUG__ && console.log(loader.key + " is loading ...");
      message = await loadMessage(locale, loader, cacheMessages);
    }
    if (message != null) {
      deepCopy(message, targetMessage);
    }
  }
  setter(locale, targetMessage);
}
